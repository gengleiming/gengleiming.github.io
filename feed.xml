<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://gengleiming.github.io/</id><title>Geng Leiming</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2022-07-12T10:35:15+08:00</updated> <author> <name>Geng Leiming</name> <uri>https://gengleiming.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://gengleiming.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://gengleiming.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Geng Leiming </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>go - 深入理解内存逃逸</title><link href="https://gengleiming.github.io/posts/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/" rel="alternate" type="text/html" title="go - 深入理解内存逃逸" /><published>2020-09-05T22:05:11+08:00</published> <updated>2022-07-12T10:31:42+08:00</updated> <id>https://gengleiming.github.io/posts/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</id> <content src="https://gengleiming.github.io/posts/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/" /> <author> <name>Geng Leiming</name> </author> <category term="go" /> <summary> 声明：本博客内容属于原创作品 前言 对于内存逃逸这块的知识，我查阅了很多资料和博客，发现大部分对这部分的知识整理总结的并不是很好，于是我对此就做了一次比较全面的总结。 准备知识 引用类型：包括 指针, slice, map, chan, func, interface 几种类型 动态类型：所谓动态类型就是程序运行时才知道的类型，interface 就是动态类型 逃逸分析：可通过 go build -gcflags="-m -l" ... 来进行逃逸分析 内存逃逸主要分为以下几大类： 指针逃逸 多级间接赋值逃逸 动态类型发生逃逸 栈空间不足发生逃逸 动态分配不定空间发生逃逸 下面来详细解释这几点 一、指针逃逸：局部变量被外部引用发生逃逸 函数返回了引用类型的局部变量，比如返回 指针、slice、map、channel、函数、接口等 其中 c... </summary> </entry> <entry><title>go并发编程 - sync.Mutex源码研究</title><link href="https://gengleiming.github.io/posts/go-mutex/" rel="alternate" type="text/html" title="go并发编程 - sync.Mutex源码研究" /><published>2020-09-03T22:23:00+08:00</published> <updated>2020-09-03T22:23:00+08:00</updated> <id>https://gengleiming.github.io/posts/go-mutex/</id> <content src="https://gengleiming.github.io/posts/go-mutex/" /> <author> <name>Geng Leiming</name> </author> <category term="go" /> <summary> 声明：本博客内容属于原创作品 版本 go版本为 1.18.2 一、sync.Mutex </summary> </entry> <entry><title>go - Slice几点深究</title><link href="https://gengleiming.github.io/posts/go-slice/" rel="alternate" type="text/html" title="go - Slice几点深究" /><published>2020-08-09T21:55:23+08:00</published> <updated>2020-08-09T21:55:23+08:00</updated> <id>https://gengleiming.github.io/posts/go-slice/</id> <content src="https://gengleiming.github.io/posts/go-slice/" /> <author> <name>Geng Leiming</name> </author> <category term="go" /> <summary> 声明：本博客内容属于原创作品 一、关于slice元素的可寻址性 我们都知道 map 的元素是不可寻址的，原因是扩容之后的原始地址会引发一些误导，同时也会影响gc。 而 slice 也会扩容，那么为什么它的元素是可寻址的呢？ 答案是因为 slice 底层存储了一个指向数组的指针，它是可以寻址的。 也因此，无论 slice 是否可寻址，slice 的元素都是可寻址的。 下面是map、数组、slice的可寻址性示例： // 1. 下面这句编译错误：cannot take address of [...]int{…}[0] l := &amp;amp;[...]int{1, 2, 3}[0] // 编译错误！ // 2. 下面这句正常运行：切片字面量元素可寻址 s := &amp;amp;[]int{1, 2, 3}[0] // 正确 fmt.Println(s) // 0xc00... </summary> </entry> </feed>
