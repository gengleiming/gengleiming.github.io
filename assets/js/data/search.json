[ { "title": "go - 深入理解内存逃逸", "url": "/posts/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/", "categories": "go", "tags": "go, 内存逃逸", "date": "2020-09-05 22:05:11 +0800", "snippet": " 声明：本博客内容属于原创作品前言对于内存逃逸这块的知识，我查阅了很多资料和博客，发现大部分对这部分的知识整理总结的并不是很好，于是我对此就做了一次比较全面的总结。准备知识引用类型：包括 指针, slice, map, chan, func, interface 几种类型 动态类型：所谓动态类型就是程序运行时才知道的类型，interface 就是动态类型 逃逸分析：可通过 go build -gcflags=\"-m -l\" ... 来进行逃逸分析内存逃逸主要分为以下几大类： 指针逃逸 多级间接赋值逃逸 动态类型发生逃逸 栈空间不足发生逃逸 动态分配不定空间发生逃逸下面来详细解释这几点一、指针逃逸：局部变量被外部引用发生逃逸函数返回了引用类型的局部变量，比如返回 指针、slice、map、channel、函数、接口等其中 channel 比较特殊，因为 channel 的创建都是调用 mallocgc 方法进行内存分配，所以 channel 都是在堆上创建的，也就不需要进行逃逸分析了。接下来我们看看其他几种类型的逃逸分析情况：package mainfunc Func1() *int {\tnum := 0 // moved to heap: num\treturn &amp;num}func Func2() []int {\ts := []int{0} // []int{...} escapes to heap\treturn s}func Func3() map[string]string {\tm := make(map[string]string) // make(map[string]string) escapes to heap\tm[\"key\"] = \"value\"\treturn m}func Func5() interface{} {\treturn 0 // 0 escapes to heap}func Func6() func() {\treturn func() {} // func literal escapes to heap}func Func7() func() {\ti := 1 // moved to heap: i，局部变量被下面的闭包引用\treturn func() {\t\ti++\t} // func literal escapes to heap}执行 go build -gcflags=\"-m -l\" main.go ，逃逸分析结果为：# command-line-arguments./main.go:4:2: moved to heap: num./main.go:9:12: []int{...} escapes to heap./main.go:13:11: make(map[string]string) escapes to heap./main.go:19:9: 0 escapes to heap./main.go:22:9: func literal escapes to heap./main.go:25:2: moved to heap: i./main.go:26:9: func literal escapes to heap# command-line-argumentsruntime.main_main·f: function main is undeclared in the main package总结局部变量被外部引用时会发生逃逸，包括函数返回引用类型，变量被闭包引用等。 注意：闭包引用的外部变量也会发生逃逸，道理是一样的。二、多级间接赋值逃逸：引用类型的元素或属性为引用类型以下几种情况，它们的元素都会发生逃逸： slice 的元素为引用类型 map 的key或value为引用类型 chan 的元素类型为引用类型 *struct 的属性为引用类型 以此类推…下面请看示例验证：package mainfunc main() {\ta := make([]*int, 1)\tnum := 1 // moved to heap: num\ta[0] = &amp;num\tb := make(map[*string]*string)\tkey := \"key\" // moved to heap: key\tvalue := \"value\" // moved to heap: value\tb[&amp;key] = &amp;value //\tc := make(chan *int)\tn := 2 // moved to heap: n\tc &lt;- &amp;n\td := make(map[interface{}]interface{})\td[\"key\"] = \"value\" // \"key\" escapes to heap; \"value\" escapes to heap\te := make(chan func())\te &lt;- func() {} // func literal escapes to heap\tf := make(chan interface{})\tf &lt;- 100 // 100 escapes to heap\tg := make(chan []int)\tg &lt;- make([]int, 1) // make([]int, 1) escapes to heap\th := make(chan map[string]string)\th &lt;- map[string]string{} // map[string]string{} escapes to heap\titem := &amp;struct {\t\tname *string\t\tage *int\t}{}\thello := \"hello\" // moved to heap: hello\titem.name = &amp;hello}执行 go build -gcflags=\"-m -l\" main.go ，逃逸分析结果为：# command-line-arguments./main.go:5:2: moved to heap: num./main.go:9:2: moved to heap: key./main.go:10:2: moved to heap: value./main.go:14:2: moved to heap: n./main.go:37:2: moved to heap: hello./main.go:4:11: make([]*int, 1) does not escape./main.go:8:11: make(map[*string]*string) does not escape./main.go:17:11: make(map[interface {}]interface {}) does not escape./main.go:18:2: \"key\" escapes to heap./main.go:18:2: \"value\" escapes to heap./main.go:21:7: func literal escapes to heap./main.go:24:2: 100 escapes to heap./main.go:27:11: make([]int, 1) escapes to heap./main.go:30:24: map[string]string{} escapes to heap./main.go:32:10: &amp;struct { name *string; age *int }{} does not escape总结当 slice, map, chan 或 指针类型 的元素或属性为引用类型（ 指针，slice，map，chan，func，interface ）时，元素会发生逃逸。三、interface{} 发生逃逸（同时纠正网络上大量的错误分析） interface{}的动态类型逃逸，本质上还是指针逃逸。 比如，interface作为slice、map、chan的元素，或引用类型的属性，或函数的返回类型等，这些情况请看上面第二类，不再赘述。 接口类型调用方法，会发生逃逸 请看下面的例子： package main type foo interface { func1() } type myType struct{} func (m myType) func1() {} func main() { var iFoo foo iFoo = myType{} // myType{} escapes to heap iFoo.func1() } 逃逸分析结果为： # command-line-arguments ./main.go:13:2: myType{} escapes to heap 另外，关于网络上大量的例子中 fmt 包打印变量出现了逃逸，但是并没有看到有人深入研究到底为什么发生逃逸，甚至有很多人错误的理解成：函数的参数为 interface 类型，那么就会发生逃逸。实际上，这种理解是完全错误的。比如下面这个例子：package mainimport \"fmt\"func main() {\ts := \"Escape\" // s escapes to heap\tfmt.Println(s)}执行 go build -gcflags=\"-m -l\" main.go ，逃逸分析结果为：# command-line-arguments./main.go:7:13: ... argument does not escape./main.go:7:13: s escapes to heap可以看到，这里 s 发生了逃逸。再看一个例子：package mainfunc main() {\tstr := \"hello\"\tFunc1(str)}func Func1(a interface{}) {}执行 go build -gcflags=\"-m -l\" main.go ，逃逸分析结果为：# command-line-arguments./main.go:8:12: a does not escape./main.go:5:7: str does not escape由此可见，interface{} 作为函数入参并不会发生逃逸。那么问题来了，上面的例子 fmt.Println(s) 到底为什么发生了逃逸了呢？这个时候，就需要看一下源码实现了：func Println(a ...any) (n int, err error) {\treturn Fprintln(os.Stdout, a...)}func Fprintln(w io.Writer, a ...any) (n int, err error) {\tp := newPrinter()\tp.doPrintln(a)\tn, err = w.Write(p.buf)\tp.free()\treturn}func newPrinter() *pp {\tp := ppFree.Get().(*pp)\tp.panicking = false\tp.erroring = false\tp.wrapErrs = false\tp.fmt.init(&amp;p.buf)\treturn p // p 逃逸到堆上}func (p *pp) doPrintln(a []any) {\tfor argNum, arg := range a {\t\tif argNum &gt; 0 {\t\t\tp.buf.writeByte(' ')\t\t}\t\tp.printArg(arg, 'v')\t}\tp.buf.writeByte('\\n')}func (p *pp) printArg(arg any, verb rune) {\tp.arg = arg\tp.value = reflect.Value{} ...}分析如下： newPrinter 函数返回了指针类型 *pp，导致 p 逃逸到了堆上，同时返回的 p 为引用类型 Fprintln 调用了 p.doPrintln(a)，继续调用了 p.printArg(arg, 'v')，最终在该函数内部执行了 p.arg = arg 由于 p 为引用类型，arg 也为引用类型 ( interface 类型)，因此可得出结论： arg 发生了逃逸 arg 来源于 fmt.Println(s) 中传入的 s，得出最终结论：s 发生了逃逸四、栈空间不足发生逃逸操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB。goroutine 的初始栈大小为 2 KB。当 goroutine 被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统的限制。如果栈空间分配的内存大小超过上限，那么会逃逸到堆上。举例说明：package mainfunc func1() {\ts := make([]int, 10240) // make([]int, 10240) escapes to heap\t_ = s}分析结果为：# command-line-arguments./main.go:4:11: make([]int, 10240) escapes to heap# command-line-argumentsruntime.main_main·f: function main is undeclared in the main package五、动态分配不定的空间发生逃逸动态分配不定的空间时，编译器无法在编译期确认需要分配的内存大小，因此会逃逸到堆上。package mainfunc func1() {\tl := 1\ts := make([]int, l) // make([]int, l) escapes to heap\t_ = s}逃逸分析结果为：# command-line-arguments./main.go:5:11: make([]int, l) escapes to heap# command-line-argumentsruntime.main_main·f: function main is undeclared in the main package" }, { "title": "go并发编程 - sync.Mutex源码研究", "url": "/posts/go-mutex/", "categories": "go", "tags": "go, 并发编程, sync", "date": "2020-09-03 22:23:00 +0800", "snippet": " 声明：本博客内容属于原创作品版本go版本为 1.18.2一、sync.Mutex" }, { "title": "go - Slice几点深究", "url": "/posts/go-slice/", "categories": "go", "tags": "go, slice", "date": "2020-08-09 21:55:23 +0800", "snippet": " 声明：本博客内容属于原创作品 一、关于slice元素的可寻址性 我们都知道 map 的元素是不可寻址的，原因是扩容之后的原始地址会引发一些误导，同时也会影响gc。而 slice 也会扩容，那么为什么它的元素是可寻址的呢？答案是因为 slice 底层存储了一个指向数组的指针，它是可以寻址的。也因此，无论 slice 是否可寻址，slice 的元素都是可寻址的。下面是map、数组、slice的可寻址性示例：// 1. 下面这句编译错误：cannot take address of [...]int{…}[0]l := &amp;[...]int{1, 2, 3}[0] // 编译错误！// 2. 下面这句正常运行：切片字面量元素可寻址s := &amp;[]int{1, 2, 3}[0] // 正确fmt.Println(s) // 0xc00000c120// 3. slice虽然不可寻址，但是它的元素可寻址getSlice := func() []int {\treturn []int{1, 2, 3}}// 下面这句编译错误：cannot take address of getSlice() (value of type []int)s := &amp;getSlice() // 编译错误！// 下面这句正常运行：函数返回的 slice 虽然不可寻址，但是它的元素可寻址ss := &amp;getSlice()[0] // 正确！fmt.Println(ss) // 0xc00000c120二、关于slice是值传递还是引用传递众所周知，go的参数传递都是值传递。那么问题来了，为什么值传递的 slice 作为参数传递之后，在函数内部修改了 slice，它却能影响到外部的 slice 呢？其实一看 slice 的底层结构就明白了（运行时切片可由 reflect.SliceHeader 结构体表示）type SliceHeader struct { Data uintptr Len int Cap int} Data 是指向数组的指针 Len 是当前切片元素的个数 Cap 是当前切片的容量slice 本质上是一个结构体，根据结构体字段不难看出，slice存储了指向底层数据的地址，通过值传递拷贝地址的方式，即可实现函数内部直接修改底层数组。三、关于扩容的注意事项 先来看一个例子： s := []int{5} s = append(s, 7) s = append(s, 9) x := append(s, 11) y := append(s, 12) fmt.Println(s, x, y) 这段代码输出结果为： [5 7 9] [5 7 9 12] [5 7 9 12] 看起来有点奇怪，实际上原理很简单，下面分步解析： s := []int{5}，这一步切片 s 的长度 len=1，容量 cap=1，底层数组为 [5] s = append(s, 7) ，这一步切片 s 的长度 len=2，容量翻倍 cap=2，底层数组变为 [5, 7] s = append(s, 9)，这一步切片 s 的长度 len=3，容量继续翻倍 cap=4，底层数组变为 [5,7,9,0] x := append(s, 11)，这一步切片 x 的长度 len=4，容量未超限保持不变 cap=4，底层数组变为 [5,7,9,11] y := append(s, 12)，这一步切片 y 的长度 len=4，容量未超限保持不变 cap=4，底层数组变为 [5,7,9,12] 由于 x，y 在 append 并没有引发扩容，因此 x，y 和 s 共享底层数组，因此它们的底层数组都为 [5,7,9,12] 最后根据 len(s)=3，len(x)=4，len(y)=4 不难得出以上示例结果 来看看官方文档对 append 怎么说： The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself 因此，如果在对silice调用append函数，但是结果却没有assign回原来的变量，这种用法通常是错误的。为了防止有副作用发生，务必要重新 assign 回原来的变量。 再看一个例子 s := []int8{1} fmt.Printf(\"len: %d, cap: %d\\n\", len(s), cap(s)) s = append(s, 1) fmt.Printf(\"len: %d, cap: %d\\n\", len(s), cap(s)) s = append(s, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15) fmt.Printf(\"len: %d, cap: %d\\n\", len(s), cap(s)) 这段代码输出结果为： len: 1, cap: 1 len: 2, cap: 8 len: 17, cap: 24 是不是有点意外？接下来，看下切片扩容的源码逻辑 runtime.growslice func growslice(et *_type, old slice, cap int) slice { // …… newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap { newcap = cap } else { const threshold = 256 if old.cap &lt; threshold { newcap = doublecap } else { for 0 &lt; newcap &amp;&amp; newcap &lt; cap { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } if newcap &lt;= 0 { newcap = cap } } } // …… capmem = roundupsize(uintptr(newcap) * ptrSize) newcap = int(capmem / ptrSize) } 从源码中不难看出扩容的规则： 在原来的 slice 容量 oldcap 小于256的时候，新 slice 的容量 newcap 是 oldcap 的2倍。 当 oldcap 容量大于等于 256 的时候，newcap = oldcap+(oldcap+3*256)/4。 新生成的容量 newcap 还需要做一个容量对齐的操作，也就是新 slice 的容量是要 大于等于 这个 newcap 的。 关于内存对齐，详情可查阅go内存管理知识。针对上述示例，简单点说就是go在分配内存的时候是按照 8、16、24、32字节…分配的，不足对应内存大小的会补齐大小。 比如，元素个数为1容量为8的 []int8 切片，append了16个元素之后拥有17个元素。每个元素1字节，总共17字节。接下来，找到能够分配17字节的最小的分配单位是24字节，因此切片最终被分配了24字节大小，而24字节大小的 []int8 切片的容量正好是24。 四、其他注意事项 slice 之间虽然不可比较，但是 slice 可以和 nil 比较。不过对于判断 slice 是否为空，一般使用 len() 函数来判断可能更好。 s2 := []int{} fmt.Println(s2 == nil, len(s2)) // false 0 var s3 []int fmt.Println(s3 == nil, len(s3)) // true 0 只有当切片底层数据指针为空时，切片才为nil，这时候切片的长度和容量信息将是无效的。 " } ]
