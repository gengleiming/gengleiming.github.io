---
title: go - Slice几点深究
date: 2019-08-09 20:55:00 +0800
categories: [go]
tags: [go, slice]
pin: false
---

## 关于slice元素的可寻址性
我们都知道 `map` 的元素是不可寻址的，原因是扩容之后的原始地址会引发一些误导，同时也会影响gc。  
而 `slice` 也会扩容，那么为什么它的元素是可寻址的呢？

答案是因为 `slice` 底层存储了一个指向数组的指针，它是可以寻址的。

也因此，无论 `slice` 是否可寻址，`slice` 的元素都是可寻址的。  

下面是map、数组、slice的可寻址性示例：
```go
// 1. 下面这句编译错误：cannot take address of [...]int{…}[0]
l := &[...]int{1, 2, 3}[0] // 编译错误！

// 2. 下面这句正常运行：切片字面量元素可寻址
s := &[]int{1, 2, 3}[0]  // 正确
fmt.Println(s) // 0xc00000c120

// 3. slice虽然不可寻址，但是它的元素可寻址
getSlice := func() []int {
	return []int{1, 2, 3}
}
// 下面这句编译错误：cannot take address of getSlice() (value of type []int)
s := &getSlice()  // 编译错误！
// 下面这句正常运行：函数返回的 slice 虽然不可寻址，但是它的元素可寻址
ss := &getSlice()[0]  // 正确！
fmt.Println(ss)  // 0xc00000c120
```
## 关于slice是值传递还是引用传递
众所周知，go的参数传递都是值传递。  
那么问题来了，为什么 `slice` 作为参数传递之后，在函数内部修改了 `slice`，它却能影响到外部的 `slice`呢？

先看一下 `slice` 的底层结构，运行时切片可由 `reflect.SliceHeader` 结构体表示
```go
type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
```
- Data 是指向数组的指针
- Len 是当前切片元素的个数
- Cap 是当前切片的容量

slice本质上是一个结构体，根据结构体字段不难看出，slice存储了指向底层数据的地址，通过值传递拷贝地址的方式，即可实现函数内部直接修改底层数组。

## 关于扩容的注意事项


## 其他注意事项

1. `slice` 之间虽然不可比较，但是 `slice` 可以和 `nil` 比较。不过对于判断 `slice` 是否为空，一般使用 `len()` 函数来判断可能更好。
```go
s2 := []int{}
fmt.Println(s2 == nil, len(s2)) // false 0

var s3 []int
fmt.Println(s3 == nil, len(s3)) // true 0
```
只有当切片底层数据指针为空时，切片才为nil，这时候切片的长度和容量信息将是无效的。